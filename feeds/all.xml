<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>陶克勤的博客</title><link>http://taokeqin.github.io/</link><description>把不可能变成可能，把困难变成简单，把简单变成傻瓜，把idea变成现实，一个程序员的旅程</description><atom:link href="taokeqin.com/feeds/all.xml" rel="self"></atom:link><lastBuildDate>Wed, 06 May 2015 00:00:00 +0200</lastBuildDate><item><title>Rust 网路编程 2 echo server</title><link>http://taokeqin.github.io/rust-network-echo-server.html</link><description>&lt;p&gt;这次尝试离之前又过去了三个月了，rust已经进入了beta了：&lt;/p&gt;
&lt;p&gt;rustc 1.0.0-beta.4 (850151a75 2015-04-30) (built 2015-05-01)&lt;/p&gt;
&lt;p&gt;不光是网路部分，整个rust较之前都有了不小的变化。&lt;/p&gt;
&lt;p&gt;在第一部分里面（代码在最新的rust是肯定不能用的了），我感受了一下rust的基本网络编程。但什么事情都还没有做。
这个第二部分就是来完成一个echo server.&lt;/p&gt;
&lt;p&gt;我还是依据一个rfc来：&lt;a class="reference external" href="http://tools.ietf.org/html/rfc862"&gt;http://tools.ietf.org/html/rfc862&lt;/a&gt;
这里就只实现tcp部分。
直接贴代码了，算是个笔记&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kn"&gt;use&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;net&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;TcpListener&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;TcpStream&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="kn"&gt;use&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;thread&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="kn"&gt;use&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;io&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;Read&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Write&lt;/span&gt;&lt;span class="p"&gt;};&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="c1"&gt;// 单个连接的处理函数&lt;/span&gt;
&lt;span class="k"&gt;fn&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;handle_client&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;mut&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;stream&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;TcpStream&lt;/span&gt;&lt;span class="p"&gt;){&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kd"&gt;let&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;peer_addr&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;stream&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;peer_addr&lt;/span&gt;&lt;span class="p"&gt;().&lt;/span&gt;&lt;span class="n"&gt;unwrap&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nb"&gt;println&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;connected from: {} &amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;peer_addr&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kd"&gt;let&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;mut&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;100&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;loop&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="kd"&gt;let&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;len&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;stream&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;read&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="k"&gt;mut&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;unwrap&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;len&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="nb"&gt;println&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Peer shutdown!&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="k"&gt;break&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;{} say: &amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;peer_addr&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;in&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mf"&gt;0.&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;len&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;{}&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;as&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;char&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="c1"&gt;// echo to client&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="kd"&gt;let&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;_&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;stream&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;write&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mf"&gt;0.&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;len&lt;/span&gt;&lt;span class="p"&gt;]).&lt;/span&gt;&lt;span class="n"&gt;unwrap&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="k"&gt;fn&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="c1"&gt;//RFC 说echo server要运行在端口7，这里就运行在7777吧，万恶的unwrap!&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kd"&gt;let&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;listener&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;TcpListener&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;bind&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;127.0.0.1:7777&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;unwrap&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;stream&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;in&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;listener&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;incoming&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;match&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;stream&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="nb"&gt;Ok&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;stream&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;                &lt;/span&gt;&lt;span class="c1"&gt;//这里对每一个accept的链接，启动一个线程来处理&lt;/span&gt;
&lt;span class="w"&gt;                &lt;/span&gt;&lt;span class="c1"&gt;//线程函数是个colsure,不带参数&lt;/span&gt;
&lt;span class="w"&gt;                &lt;/span&gt;&lt;span class="c1"&gt;//捕获上下文里面的stream变量，强制move&lt;/span&gt;
&lt;span class="w"&gt;                &lt;/span&gt;&lt;span class="n"&gt;thread&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="nb"&gt;spawn&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;move&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;||&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;                    &lt;/span&gt;&lt;span class="n"&gt;handle_client&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;stream&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;                &lt;/span&gt;&lt;span class="p"&gt;});&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="nb"&gt;Err&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;                &lt;/span&gt;&lt;span class="nb"&gt;println&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Fucked by the network problem: {} &amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;            &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;很多错误没有处理，都直接unwrap了。&lt;/p&gt;
&lt;p&gt;下一个试试写一个聊天室程序吧。用一个非常简单需求：&lt;/p&gt;
&lt;p&gt;1，服务器启动&lt;/p&gt;
&lt;p&gt;2，客户端连接，发送消息到服务器&lt;/p&gt;
&lt;p&gt;3，服务器广播消息到所有连接的客户端&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">陶克勤</dc:creator><pubDate>Wed, 06 May 2015 00:00:00 +0200</pubDate><guid>tag:taokeqin.github.io,2015-05-06:rust-network-echo-server.html</guid><category>rust</category><category>netwrok</category></item><item><title>Rust 网路编程 1</title><link>http://taokeqin.github.io/rust-network-one.html</link><description>&lt;div class="section" id="start"&gt;
&lt;h2&gt;Start&lt;/h2&gt;
&lt;p&gt;虽然现在rust的网络部分还很初级，基本都处在unstable状态。
不过简单的试试网络编程还是没问题。&lt;/p&gt;
&lt;p&gt;最简单标准的tcp server流程：&lt;/p&gt;
&lt;pre class="literal-block"&gt;
bind

listen

accept
&lt;/pre&gt;
&lt;p&gt;这样就可以开始接受外部链接。&lt;/p&gt;
&lt;p&gt;看看rust里面是这些步骤是该怎么做？&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="bind"&gt;
&lt;h2&gt;bind&lt;/h2&gt;
&lt;p&gt;通过TcpListener结构来进行bind和listen。&lt;/p&gt;
&lt;p&gt;在impl TcpListener下面有&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;fn&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;bind&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;ToSocketAddr&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;addr&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;IoResult&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;TcpListener&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;从上面的函数的定义可以看出，bind是TcpListener的static方法，通过::调用就可以了。&lt;/p&gt;
&lt;p&gt;为什么是static方法？没有&amp;amp;self参数在第一个参数位置呗，很简单。&lt;/p&gt;
&lt;p&gt;同时上面这个接口也是个很典型的泛型接口。&lt;/p&gt;
&lt;p&gt;参数：addr 类型 A，要求A必须要实现ToSocketAddr traits&lt;/p&gt;
&lt;p&gt;返回值：IoResult&amp;lt;TcpListener&amp;gt;&lt;/p&gt;
&lt;p&gt;rust里面的惯用法就是用这种result集合进行返回。
对于这个结果，经常的如果这个结果不需要进行错误处理，就直接把结果unwrap出来，出错就结束运行。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;//为了简单起见，引入io里面的所有东西.&lt;/span&gt;
&lt;span class="kn"&gt;use&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;io&lt;/span&gt;&lt;span class="o"&gt;::*&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="k"&gt;fn&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;     &lt;/span&gt;&lt;span class="kd"&gt;let&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;listener&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;io&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;TcpListener&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;bind&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;127.0.0.1:9999&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;unwrap&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个程序是没有问题的，我们bind到一个地址，用unwrap进结果判断，如果成功，就把真正的listener绑定到左边变量。&lt;/p&gt;
&lt;p&gt;值得注意的是bind的参数是一个字符串常量&amp;amp;str，文档中可以看到&amp;amp;str是实现了ToSocketAddr这个traits的。
开始我都觉得难以置信。&lt;/p&gt;
&lt;p&gt;下面进行&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="listen"&gt;
&lt;h2&gt;listen&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;impl&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Listener&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;TcpStream&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;TcpAcceptor&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;TcpListener&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="k"&gt;fn&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;listen&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;IoResult&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;TcpAcceptor&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;从上面的接口，我们可以调用TcpListener的listen成员方法来得到一个IoResult&amp;lt;TcpAcceptor&amp;gt;
从这个接口来看，这里是一个值语义的self，如果TcpListener没有实现Copy的traits,这个地方就只能是move了。
也就是说，TcpListener在调用listen的时候，会把自己“消耗”掉，下面的代码都不能再使用了。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kn"&gt;use&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;io&lt;/span&gt;&lt;span class="o"&gt;::*&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="k"&gt;fn&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kd"&gt;let&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;listener&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;io&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;TcpListener&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;bind&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;127.0.0.1:9999&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;unwrap&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kd"&gt;let&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;acceptor&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;listener&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;listen&lt;/span&gt;&lt;span class="p"&gt;().&lt;/span&gt;&lt;span class="n"&gt;unwrap&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当我们有了一个acceptor的时候，我们看看怎讲来accept一个链接？&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="accept"&gt;
&lt;h2&gt;accept&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;impl&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;Acceptor&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;TcpStream&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;TcpAcceptor&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="k"&gt;fn&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;accept&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="k"&gt;mut&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;IoResult&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;TcpStream&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面的接口可以看出，可以直接调用TcpAcceptor的成员方法accept。但是注意这里的self是一个mut的引用。
所以我们要让acceptor不光是默认的只读&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kn"&gt;use&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;io&lt;/span&gt;&lt;span class="o"&gt;::*&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="k"&gt;fn&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kd"&gt;let&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;listener&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;io&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;TcpListener&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;bind&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;127.0.0.1:9999&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;unwrap&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kd"&gt;let&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;mut&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;acceptor&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;listener&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;listen&lt;/span&gt;&lt;span class="p"&gt;().&lt;/span&gt;&lt;span class="n"&gt;unwrap&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kd"&gt;let&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;tcpstream&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;acceptor&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;accept&lt;/span&gt;&lt;span class="p"&gt;().&lt;/span&gt;&lt;span class="n"&gt;unwrap&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;有了上面的代码，我就可以accept一个链接进来了。&lt;/p&gt;
&lt;p&gt;为了看看效果，我们看看Tcpstream的文档，打印一些链接信息出来，最简单的就是看看对端的ip，端口。&lt;/p&gt;
&lt;p&gt;下面这个函数看起来就不错&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;fn&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;peer_name&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="k"&gt;mut&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;IoResult&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;SocketAddr&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其实从Tcpstream的接口来看，很多也需要可以能需要改变Tcpstream的内部状态。因为参数都要求是&amp;amp;mut self&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kn"&gt;use&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;io&lt;/span&gt;&lt;span class="o"&gt;::*&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="k"&gt;fn&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kd"&gt;let&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;listener&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;io&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;TcpListener&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;bind&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;127.0.0.1:9999&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;unwrap&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kd"&gt;let&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;mut&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;acceptor&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;listener&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;listen&lt;/span&gt;&lt;span class="p"&gt;().&lt;/span&gt;&lt;span class="n"&gt;unwrap&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kd"&gt;let&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;mut&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;tcpstream&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;acceptor&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;accept&lt;/span&gt;&lt;span class="p"&gt;().&lt;/span&gt;&lt;span class="n"&gt;unwrap&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kd"&gt;let&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;socketaddr&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;tcpstream&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;peer_name&lt;/span&gt;&lt;span class="p"&gt;().&lt;/span&gt;&lt;span class="n"&gt;unwrap&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="nb"&gt;println&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;connection from: {}&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;socketaddr&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面的代码就是一个最基本接收一个连接的server了，然后写个client试试。
只有一行一行，当然我们只是看这个链接建立的情况，不传数据。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kn"&gt;use&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;io&lt;/span&gt;&lt;span class="o"&gt;::*&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;

&lt;span class="k"&gt;fn&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="kd"&gt;let&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;mut&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;stream&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;TcpStream&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;connect&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;127.0.0.1:9999&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;unwrap&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最后，我没有任何关闭socket的操作是不是有问题？&lt;/p&gt;
&lt;/div&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">陶克勤</dc:creator><pubDate>Sun, 08 Feb 2015 00:00:00 +0100</pubDate><guid>tag:taokeqin.github.io,2015-02-08:rust-network-one.html</guid><category>rust</category><category>netwrok</category></item><item><title>rust hello world</title><link>http://taokeqin.github.io/rust-hello.html</link><description>&lt;div class="section" id="hi"&gt;
&lt;h2&gt;HI&lt;/h2&gt;
&lt;p&gt;第一次看到rust这个语言是在一个Lang.Next的视频上，当时有一个对话场景，上面坐着4个人再回答下面的提问！&lt;/p&gt;
&lt;p&gt;这四个人所负责的语言分别是：C++, D, rust, go&lt;/p&gt;
&lt;p&gt;瞬间发现自己居然不知道rust这个语言呢！&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id1"&gt;
&lt;h2&gt;我为什么想试试这个语言&lt;/h2&gt;
&lt;p&gt;rust定位是系统编程语言，强类型，强调安全，强调并行, 不用GC, 不用异常&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="rust"&gt;
&lt;h2&gt;怎么安装rust&lt;/h2&gt;
&lt;p&gt;目前的安装方式在linux比较暴力，windows还好，直接下载安装包就可以了&lt;/p&gt;
&lt;p&gt;linux:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;curl -s https://static.rust-lang.org/rustup.sh &lt;span class="p"&gt;|&lt;/span&gt; sudo sh
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个安装脚本是会默认安装两个东西：rust， cargo&lt;/p&gt;
&lt;p&gt;cargo是rust的代码依赖管理和build工具，对于习惯了make，cmake这样工具的人，还是会觉得cargo比较方便些。
后面详细分析一下cargo的使用，目前cargo还在开发阶段，特性不多，容易掌握！&lt;/p&gt;
&lt;p&gt;官方推荐学习,练习rust，一开始就要使用cargo来做工程管理。
所以我在使用过一次rustc后，所有的代码就都用cargo了。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="rustc-hello-world"&gt;
&lt;h2&gt;rustc hello world&lt;/h2&gt;
&lt;p&gt;安装好了编译器之后第一步就来hello world&lt;/p&gt;
&lt;p&gt;新建文件： main.rs&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;fn&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="nb"&gt;println&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Hello World&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行命令进行编译&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$rustc&lt;/span&gt; main.rs
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到生成的二进制文件，直接运行就好了。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="cargo-hello-world"&gt;
&lt;h2&gt;cargo hello world&lt;/h2&gt;
&lt;p&gt;cargo有直接的工程创建模板，或者可以手动按照cargo的约定进行代码布局&lt;/p&gt;
&lt;p&gt;约定的好处就是大家干出来的结果都一样. 不像make，每个人的工程都不一样！&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;cargo new hello_world --bin
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;找一个你放代码的目录，运行上面的命令，cargo就会帮你生成一个工程模板。
看看目录里面都有写什么？&lt;/p&gt;
&lt;p&gt;src里面的源代码，写代码就写在里面！&lt;/p&gt;
&lt;p&gt;Cargo.toml是cargo的配置文件，可以看到，这里没并没有指明有那些源文件？？&lt;/p&gt;
&lt;p&gt;很好奇rustc的编译链接过程？后面详细分析，至少来看比c/c++简化了程序员的决策。&lt;/p&gt;
&lt;p&gt;编译产生二进制运行文件&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;cargo build
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;会生成一个target目录，可执行文件也在里面，直接运行就好了，这样build也很不错，产生的中间文件都在src的外面，代码比较整洁！&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;cargo clean
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;就轻易的清理掉了build的输出，看看目录，target目录消失了！！&lt;/p&gt;
&lt;/div&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">陶克勤</dc:creator><pubDate>Tue, 14 Oct 2014 10:17:00 +0200</pubDate><guid>tag:taokeqin.github.io,2014-10-14:rust-hello.html</guid><category>rust</category><category>hello</category></item><item><title>python realtime</title><link>http://taokeqin.github.io/python-realtime.html</link><description>&lt;div class="section" id="id1"&gt;
&lt;h2&gt;声明&lt;/h2&gt;
&lt;p&gt;本文是基于一篇英文文章翻译过来的。&lt;/p&gt;
&lt;p&gt;原文链接：&lt;a class="reference external" href="http://mrjoes.github.io/2013/06/21/python-realtime.html"&gt;http://mrjoes.github.io/2013/06/21/python-realtime.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;原作者： Serge Koval&lt;/p&gt;
&lt;p&gt;License：Creative Commons attribution-noncommercial-sharealike License&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id2"&gt;
&lt;h2&gt;简介&lt;/h2&gt;
&lt;p&gt;最近我参与了 &lt;a class="reference external" href="http://www.kickstarter.com/projects/1223051718/practical-flask-book-project"&gt;Flask book&lt;/a&gt; 的一次聚会,涉及到些realtime相关的问题-它是如何工作的，
如何整合实时部分与传统的WSGI应用，如何组织应用程序代码等。&lt;/p&gt;
&lt;p&gt;我们使用Google Hangouts，原本打算将我们的Hangouts视频录下来，但失败了。
所以，我决定还是写一篇详尽的博客文章，其中包括一些基础知识，以及简短的介绍用Python异步编程等。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id3"&gt;
&lt;h2&gt;一点理论知识&lt;/h2&gt;
&lt;p&gt;让我们尝试解决服务器&amp;quot;推送&amp;quot;的问题。web都是拉取数据 - 浏览器发出请求到服务器，服务器会产生并发送回响应。
但是，如果有需要将数据主动从服务器推送到浏览器该怎么办呢？&lt;/p&gt;
&lt;p&gt;解决方法很简单：浏览器发出AJAX请求到服务器，并要求更新。
虽然看起来这个是常用浏览器和服务器之间推送办法，但有一个问题:&lt;/p&gt;
&lt;p&gt;如果服务器没有什么要发送，它会保持连接打开，直到为客户提供一些数据。
客户端收到响应后，它会发出另一个请求，以获得更多的数据。&lt;/p&gt;
&lt;p&gt;这种技术被称为长轮询（long-polling）。&lt;/p&gt;
&lt;p&gt;显然，这方法不不太高效。在大多数情况下，噪信比是非常高的
（无用数据比有用数据-因为这样一来更多的时间是花在处理HTTP请求（比如解析和验证报头）而不是实际数据发送到客户端。&lt;/p&gt;
&lt;p&gt;但是，不幸的是，它是目前将数据推送到客户端最适合的方式。&lt;/p&gt;
&lt;p&gt;基于HTTP/1.1情况好转了一点。TCP连接可以使用 &lt;a class="reference external" href="http://en.wikipedia.org/wiki/HTTP_persistent_connection"&gt;Keep-Alive&lt;/a&gt; 头，默认情况下，连接在请求发起后将保持打开状态。
此功能使长轮询延迟得到了降低，这样就没有必要为每个轮询请求重新打开TCP连接。&lt;/p&gt;
&lt;p&gt;HTTP/1.1还引入了 &lt;a class="reference external" href="http://wikipedia.org/wiki/Chunked_transfer_encoding"&gt;块传输协议&lt;/a&gt; 。
它允许讲响应分解为成更小的数据块，并将它们立即发送到客户端，而不是一直等到完成HTTP请求。&lt;/p&gt;
&lt;p&gt;不幸的是，有些不兼容这个功能的代理服务器还是试图在转发之前缓存整个响应，
所以客户端将不会收到任何数据，直到代理认为HTTP请求已经完成。
虽然看起来web还是能&amp;quot;正常&amp;quot;工作 - 因为客户端最终还是会得到来自服务器的响应，
但它打破了为实时而设计的块传输协议的整体思路。&lt;/p&gt;
&lt;p&gt;Opera在2006年9月，为它的浏览器实现了实验性的 &lt;a class="reference external" href="http://en.wikipedia.org/wiki/Server-sent_events"&gt;服务事件发送&lt;/a&gt; 功能。
虽然SSE和块传输协议很相似，但还是是不同的协议，而且有更好的客户端API。&lt;/p&gt;
&lt;p&gt;2009年4月23日，SSE得到WHATWG批准，得到几乎所有的现代的桌面浏览器（Internet Explorer的除外）的支持。
在这个链接你可以 &lt;a class="reference external" href="http://caniuse.com/#feat=eventsource"&gt;看到兼容性图表&lt;/a&gt; 。&lt;/p&gt;
&lt;p&gt;还有其他的技术，比如 &lt;a class="reference external" href="http://cometdaily.com/2007/11/05/the-forever-frame-technique/"&gt;forever-iframe&lt;/a&gt; 。
这是两种可以为Internet Explorer版本低于8做跨域推送的技术之一（另一个是 &lt;a class="reference external" href="http://en.wikipedia.org/wiki/JSONP"&gt;jsonp&lt;/a&gt; -polling），以及 &lt;a class="reference external" href="http://cometdaily.com/2007/10/25/http-streaming-and-internet-explorer/"&gt;HTMLFILE&lt;/a&gt; 等&lt;/p&gt;
&lt;p&gt;总之，所有这些基于HTTP的折中方案都可以叫做 &lt;a class="reference external" href="http://en.wikipedia.org/wiki/Comet_(programming"&gt;Comet&lt;/a&gt; 。&lt;/p&gt;
&lt;p&gt;让我们来看看这些方法的利弊：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;长轮询（Long-polling）是昂贵的，但兼容性很好。&lt;/li&gt;
&lt;li&gt;块传输协议效率更高，但有可能不是所有客户端都能正常工作，并且如果没有某种形式的探测你都无法发现这个问题的存在。&lt;/li&gt;
&lt;li&gt;SSE也不错，但不是所有的浏览器都支持。比较好的是有办法在建立连接前就知道它是否支持。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;但是，所有这些方法都有一个问题：
他们都只提供一种方式将数据从服务器推送到客户端，而不是在建立双向通信，
客户端每次想发送一些数据的时候，将不得不使用AJAX请求到服务器。
这样会增加延迟，并在服务器也会产生额外的负载。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="websockets"&gt;
&lt;h2&gt;邂逅WebSockets&lt;/h2&gt;
&lt;p&gt;虽然WebSockets的不是什么新技术，但经历了几个不兼容的迭代后该规范终于通过了，RFC编号：&lt;a class="reference external" href="http://tools.ietf.org/html/rfc6455"&gt;RFC-6455&lt;/a&gt; 。&lt;/p&gt;
&lt;p&gt;简而言之，基于WebSocket的服务器和客户端之间建立的是基于TCP的双向连接。
连接的建立建立使用兼容HTTP的握手协议（加上额外的WebSocket相关的头），并具有额外的协议层次划分，
所以它也不仅仅是一个从浏览器中打开原始的TCP连接。&lt;/p&gt;
&lt;p&gt;WebSocket协议最大的问题是浏览器支持，防火墙，代理服务器和防病毒应用的支持。&lt;/p&gt;
&lt;p&gt;这个链接有浏览器的 &lt;a class="reference external" href="http://caniuse.com/#feat=websockets"&gt;兼容性图表&lt;/a&gt; 。&lt;/p&gt;
&lt;p&gt;企业防火墙和代理服务器通常因各种原因阻止的WebSocket连接。&lt;/p&gt;
&lt;p&gt;有些代理服务器不能处理WebSocket在端口80上连接 - 他们认为这是一般的HTTP请求，并尝试缓存它。
有HTTP扫描组件的杀毒软件也不允许WebSocket连接。&lt;/p&gt;
&lt;p&gt;无论如何，WebSocket的来建立客户端和服务器端之间的双向通信是最好的方式，但不能单一的用来解决推送问题。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id8"&gt;
&lt;h2&gt;用例&lt;/h2&gt;
&lt;p&gt;鉴于以上情况，如果您的应用程序大多是从服务器推送数据，基于HTTP的传输会工作得很好。&lt;/p&gt;
&lt;p&gt;但是，如果浏览器支持WebSocket的传输并且WebSocket的连接是可以建立的，它将是更好的选择。&lt;/p&gt;
&lt;p&gt;总而言之，最好的办法是：尝试打开的WebSocket连接，如果失败 - 尝试回退到基于HTTP传输。
当然也有可以&amp;quot;升级&amp;quot;连接 - 首先使用长轮询（long-polling），然后尝试建立WebSocket的连接。
如果成功，就切换到WebSocket的连接。
虽然这种做法可能会降低初始连接的时间，需要注意服务器端实现，
以避免但在两者连接之间切换时发生任何的跳变情况（race conditions）。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="polyfill"&gt;
&lt;h2&gt;Polyfill库&lt;/h2&gt;
&lt;p&gt;幸运的是，你没有必要自己实现这一切。
为所有已知的浏览器提供变通方案，搞定代理和防火墙的奇怪问题，尤其是从头开始搞这些事情，是非常困难的。
已经有人投入人多年的工作使他们的解决方案尽可能稳定。&lt;/p&gt;
&lt;p&gt;有一些 &lt;a class="reference external" href="http://en.wikipedia.org/wiki/Polyfill"&gt;polyfill&lt;/a&gt; 库，像 &lt;a class="reference external" href="https://github.com/sockjs"&gt;SockJS库&lt;/a&gt; ，&lt;a class="reference external" href="http://socket.io/"&gt;Socket.IO库&lt;/a&gt; , &lt;a class="reference external" href="http://faye.jcoglan.com/"&gt;Faye&lt;/a&gt; 和其他一些框架，实现了基于各种不同的传输实现上的类WebSocket的 API。&lt;/p&gt;
&lt;p&gt;虽然他们所提供的服务器和客户端API不尽相同，但他们有着共同的理念：
在给定的情况下用最好的传输方案，并且提供一致的服务器端API。&lt;/p&gt;
&lt;p&gt;例如，如果浏览器支持WebSocket协议，polyfill将尝试建立WebSocket连接。
如果失败了，他们将下降回到下一个最好的传输协议。
&lt;a class="reference external" href="https://github.com/LearnBoost/engine.io/"&gt;Engine.IO&lt;/a&gt; 使用稍微不同的方法 - 他先建立长轮询连接（long-polling），并尝试在后台升级到WebSocket。&lt;/p&gt;
&lt;p&gt;在任何情况下 - 这些库将尝试建立双向连接到服务器上使用最可靠的传输。&lt;/p&gt;
&lt;p&gt;不幸的是，在使用Socket.IO 0.8.x的时候有较差的体验。
我一般在我自己的项目中使用 &lt;a class="reference external" href="https://github.com/mrjoes/sockjs-tornado"&gt;sockjs-tornado&lt;/a&gt; ，即使我自己写了 &lt;a class="reference external" href="https://github.com/mrjoes/tornadio2"&gt;TornadIO2&lt;/a&gt; 。
Socket.IO早期的server实现是基于 &lt;a class="reference external" href="http://tornadoweb.org/"&gt;Tornado&lt;/a&gt; 的。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id10"&gt;
&lt;h2&gt;服务器端&lt;/h2&gt;
&lt;p&gt;让我们回到Python。&lt;/p&gt;
&lt;p&gt;不幸的是，基于 &lt;a class="reference external" href="http://en.wikipedia.org/wiki/Web_Server_Gateway_Interface"&gt;WSGI&lt;/a&gt; 服务器不能被用于创建实时应用，因为WSGI协议是同步的。
WSGI服务器一次只能处理一个请求。&lt;/p&gt;
&lt;p&gt;让我们再次回顾长轮询（long-polling）传输：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;客户端打开HTTP连接到服务器，以获得更多的数据&lt;/li&gt;
&lt;li&gt;无可用数据，服务器保持连接打开并等待数据发送&lt;/li&gt;
&lt;li&gt;因为服务器无法处理任何其他请求，一切都被阻塞&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;用伪代码，它会看起来像这样：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;handle_request&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;request&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="n"&gt;data&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;get_more_data&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;request&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;send_response&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果get_more_data阻塞了，那整个服务器就会被阻塞，不能处理请求了。&lt;/p&gt;
&lt;p&gt;当然，可以每个请求创建线程，但这非常低效。&lt;/p&gt;
&lt;p&gt;虽然有一些变通办法（如 &lt;a class="reference external" href="http://lucumr.pocoo.org/2012/8/5/stateless-and-proud/"&gt;Armin Ronacher&lt;/a&gt; 所描述的方法，以及一些相关的变种将在稍后讨论，异步执行模式更适合这个任务。&lt;/p&gt;
&lt;p&gt;在异步执行模式中，服务器处理依然在一个线程中顺序处理请求，但当处理程序无事可做的时候，
可以将控制转移到另一个请求处理程序。&lt;/p&gt;
&lt;p&gt;在这种情况下，长轮询（long-polling）传输将看起来像这样：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;客户端打开HTTP连接到服务器，以获得更多的数据&lt;/li&gt;
&lt;li&gt;没有可用数据，服务器保持打开TCP连接，并同时做别的东西&lt;/li&gt;
&lt;li&gt;当有数据要发送时，服务器发送数据然后关闭连接&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;div class="section" id="greenlets"&gt;
&lt;h2&gt;Greenlets&lt;/h2&gt;
&lt;p&gt;在Python中有两种方法编写异步代码：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;使用 &lt;a class="reference external" href="http://en.wikipedia.org/wiki/Coroutine"&gt;corutines&lt;/a&gt; （也称为greenlets）&lt;/li&gt;
&lt;li&gt;使用 &lt;a class="reference external" href="http://en.wikipedia.org/wiki/Callback_(computer_programming"&gt;回调&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;简而言之，greenlets让你写出能在执行过程中暂停的功能，然后还可以继续执行。&lt;/p&gt;
&lt;p&gt;Greenlet的实现是从 &lt;a class="reference external" href="http://www.stackless.com/"&gt;Stackless Python&lt;/a&gt; 向后移植到CPython就。
虽然有greenlet模块的CPython看起来和Stackless Python是相同的 - 但他确实不是。
Stackless Python有两种上下文切换模式：软切换，硬切换。
软切换涉及到Python应用程序堆栈的切换（就是指针互换，快速并且容易）和硬切换需要堆栈分片（慢而且容易出错）。
Greenlet 基本上就是移植Stackless的硬切换模式。&lt;/p&gt;
&lt;p&gt;让我们再次看看长轮询（long-polling）的例子，这次基于greenlets：&lt;/p&gt;
&lt;blockquote&gt;
1, 客户端打开HTTP连接到服务器，以获得更多的数据
2, 服务器启动新的greenlet用来处理长轮询逻辑
3, 没有数据要发送，greenlet开始休眠，暂停当前正在执行的功能
4, 当有数据要发生的时候，greenlet唤醒，发送数据然后关闭连接&lt;/blockquote&gt;
&lt;p&gt;用伪代码，它看起来和同步版本完全一样：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;handle_request&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;request&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="c"&gt;# 如果这里没有数据, greenlet 就会休眠&lt;/span&gt;
    &lt;span class="c"&gt;# 然后切换到其他greenlet执行&lt;/span&gt;
    &lt;span class="n"&gt;data&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;get_more_data&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;request&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;make_response&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;为什么greenlets很重要？&lt;/p&gt;
&lt;p&gt;因为它们允许以同步的方式编写异步代码。
他们允许异步的使用现有的同步库。greenlet的实现隐藏了上下文切换的问题。&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="http://www.gevent.org/"&gt;GEVENT&lt;/a&gt; 是可以用greenlets实现的很好的例子。
这个框架补充了Python标准库，引入了异步IO（输入输出），在没有明显的上下文切换下使得所有代码异步。&lt;/p&gt;
&lt;p&gt;另一方面，greenlet的 CPython实现也是相当可怕的。&lt;/p&gt;
&lt;p&gt;每个协程都有自己的堆栈。CPython使用非托管堆栈的Python应用，
当Python程序运行时堆栈看起来像烤宽面条 - 解释器数据，本地模块的数据，Python应用程序的数据，
一切以随机顺序分层混合在一起。
在这种情况下，想要预留堆栈并且想无痛的做协同程序之间的上下文切换是相当困难的，因为很难预测在栈上保存的到底什么。&lt;/p&gt;
&lt;p&gt;Greenlet试图通过把一部分栈数据复制到堆，然后复制回来的方法克服这一限制。
虽然大多数情况下它是可以工作的，但任何未经测试的第三方库与原生扩展，都有可能会产生奇怪的错误，如栈或堆破坏。&lt;/p&gt;
&lt;p&gt;基于greenlets的代码实现方式也不太像线程。
因为他更容易造成死锁，代码实现中调用者其实并不希望调用的函数去暂停greenlet，但是这个函数却把greenlet暂停了，调用者将没有机会释放锁。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id12"&gt;
&lt;h2&gt;回调&lt;/h2&gt;
&lt;p&gt;做上下文切换的另一种方法是使用回调。以长轮询（long-polling）为例：&lt;/p&gt;
&lt;blockquote&gt;
1, 客户端打开HTTP连接到服务器，以获得更多的数据
2, 服务器发现有没有数据发送
3, 服务器等待数据，并传入当有数据的时候应该被调用的callback函数
4, 服务器发送响应的回调函数，并关闭连接&lt;/blockquote&gt;
&lt;p&gt;在伪代码：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;handle_request&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;request&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="n"&gt;get_more_data&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;request&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;callback&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;on_data&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;on_data&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;request&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="n"&gt;send_response&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;request&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;make_response&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;正如你看到的，工作流是相似的，但代码结构有所不同。&lt;/p&gt;
&lt;p&gt;不幸的是，回调不是很直观，而且调试基于回调的大型应用程序简直就是个噩梦。
此外，这种方式很难让现有的&amp;quot;阻塞&amp;quot;类库与异步应用一起使用，除非做一些重写或使用某种形式的线程池。
例如， &lt;a class="reference external" href="http://motor.readthedocs.org/en/stable/"&gt;Motor&lt;/a&gt; ，为Tornado用混合方式实现的异步MongoDB的驱动程序-它用greenlets封装了 IO，但提供了与Tornado兼容的异步API。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="futures"&gt;
&lt;h2&gt;Futures&lt;/h2&gt;
&lt;p&gt;有不同的方法来完善使用回调的情况：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;使用futures&lt;/li&gt;
&lt;li&gt;使用generators&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;什么是Futures？首先，Futures是一个函数的返回值，它是一个对象，它有以下几个属性：&lt;/p&gt;
&lt;blockquote&gt;
1, 函数执行的状态（idling, running，停止等）
2, 返回值（如果函数尚未执行，可能是空的）
3, 各种方法： cancel（），以防止执行，add_done_callback方法,当绑定函数执行完毕时注册回调函数等。&lt;/blockquote&gt;
&lt;p&gt;您可以看看这篇优秀的 &lt;a class="reference external" href="http://blog.jcoglan.com/2013/03/30/callbacks-are-imperative-promises-are-functional-nodes-biggest-missed-opportunity/"&gt;博客文章&lt;/a&gt; ，其中比较了promises和回调，以及为什么对于写更好的异步代码来说promises优于纯写回调。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="generators"&gt;
&lt;h2&gt;Generators&lt;/h2&gt;
&lt;p&gt;Python生成器也可让写异步程序的程序员更快乐一点。
我们还是看长轮询的例子，但这次我们基于生成器（请注意，从Python 3.3开始会允许从生成器返回值）：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nd"&gt;@coroutine&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;handle_request&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;request&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="n"&gt;data&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;yield&lt;/span&gt; &lt;span class="n"&gt;get_more_data&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;request&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;make_response&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;正如你可以看到，生成器允许编写的异步代码有点像同步方式。查看 &lt;a class="reference external" href="http://www.python.org/dev/peps/pep-0342/"&gt;PEP 342&lt;/a&gt; 获取的更多信息。&lt;/p&gt;
&lt;p&gt;生成器最大的问题：程序员在还没有调用这个函数之前必须要知道他是否是异步函数。&lt;/p&gt;
&lt;p&gt;看下面的例子：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nd"&gt;@coroutine&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;get_mode_data&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;request&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="n"&gt;data&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;yield&lt;/span&gt; &lt;span class="n"&gt;make_db_query&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;request&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;user_id&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;data&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;process_request&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;request&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="n"&gt;data&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;get_more_data&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;request&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;data&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这行代码不会得到预期的效果，在python调用生成器函数返回的生成器器对象不包含执行的内容。
在这种情况下，process_request也应该变为为异步用coroutine装饰器封装并且应该从get_more_data产生。
另一种方法 - 使用框架功能运行异步函数（如通过回调或Future回调）的能力。&lt;/p&gt;
&lt;p&gt;另一个问题 - 如果有必要使现有的函数异步，它的所有的调用者都应更新。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id14"&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;Greenlets使一切变得&amp;quot;容易&amp;quot;，但其代价是你可能遇到问题，并要允许隐式上下文切换。&lt;/p&gt;
&lt;p&gt;使用回调的代码非常的乱。Futures使得情况有所改善。生成器使代码更易于阅读。&lt;/p&gt;
&lt;p&gt;使用Python编写异步应用程序,似乎&amp;quot;官方&amp;quot;推荐的方式是使用回调/Futures/生成器，而不是greenlets。请参阅 &lt;a class="reference external" href="http://www.python.org/dev/peps/pep-3156/"&gt;PEP 3156&lt;/a&gt; 。&lt;/p&gt;
&lt;p&gt;当然，没有什么会阻止您使用greenlet框架。有选择是件好事。&lt;/p&gt;
&lt;p&gt;我更喜欢明确的上下文切换，因为在花了几个晚上生产环境中使用gdb搞清楚奇怪的解释器崩溃问题后，我对greenlets变得比较谨慎了。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id15"&gt;
&lt;h2&gt;异步框架&lt;/h2&gt;
&lt;p&gt;在大多数的情况下，完全没有必要写自己的异步网络层，应该更好地利用现有的框架。
在这里我就不一一列举所有的Python异步框架，我只说工作中使用的一个，所以不会对其他框架有所冒犯。&lt;/p&gt;
&lt;p&gt;1, GEVENT不错，使编写异步程序变得容易，但就像上面说的，我不太适应greenlets。&lt;/p&gt;
&lt;p&gt;2, Twisted是最古老的异步框架，即使是现在也有积极维护，。我个人的感受相当复杂：复杂，非PEP8，不容易学习。&lt;/p&gt;
&lt;p&gt;3, Tornado是的我最终选择的框架。有几个原因：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;快&lt;/li&gt;
&lt;li&gt;可预测的&lt;/li&gt;
&lt;li&gt;更符合Python的风格&lt;/li&gt;
&lt;li&gt;相对较小&lt;/li&gt;
&lt;li&gt;开发活跃&lt;/li&gt;
&lt;li&gt;源代码很容易阅读和理解&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;Tornado没有Twisted大，并且没有一些同步调用库的异步移植（主要是DB方面），
但附带了Twisted reactor，所以它是可以在Tornado的基础上使用为Twisted编写的模块。&lt;/p&gt;
&lt;p&gt;我会基于Tornado来解释后面所有的例子，但我敢肯定，类似的抽象同样可以用于其他框架。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id16"&gt;
&lt;h2&gt;Tornado&lt;/h2&gt;
&lt;p&gt;Tornado的结构是非常简单的。有一个主循环（称为IOLoop）。IOLoop检查socket，
文件描述符等的IO事件（借助 epoll， kqueue或select ），并管理基于时间的回调函数。
当有IO事件发生，Tornado调用注册的回调函数。&lt;/p&gt;
&lt;p&gt;例如，如果绑定在某个socket上的的连接进来，Tornado将触发相应的回调函数，
这将创建HTTP请求处理程序类，然后从socket读取头部信息。&lt;/p&gt;
&lt;p&gt;Tornado不仅只是epoll的一个封装 - 它包含自己的模板和认证系统，异步Web客户端等。&lt;/p&gt;
&lt;p&gt;如果你不熟悉Tornado，看看这个相对较短的 &lt;a class="reference external" href="http://www.tornadoweb.org/en/stable/overview.html"&gt;框架概述&lt;/a&gt; 。&lt;/p&gt;
&lt;p&gt;Tornado自带的WebSocket协议的实现，我也在这个基础上写了 &lt;a class="reference external" href="https://github.com/mrjoes/sockjs-tornado"&gt;sockjs&lt;/a&gt; 和 &lt;a class="reference external" href="https://github.com/mrjoes/tornadio2"&gt;socket.io&lt;/a&gt; 库。&lt;/p&gt;
&lt;p&gt;就像这篇文章开始的时候提到的，SockJS是WebSocket的polyfill库，在客户端是WebSocket对象，
在服务器端用socketjs-tornado提供类似的api。&lt;/p&gt;
&lt;p&gt;SockJS负责选择客户端和服务器之间最佳的可用的传输方式，并建立逻辑连接。&lt;/p&gt;
&lt;p&gt;这里是基于sockjs-tornado的简单聊天例子：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;ChatConnection&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sockjs&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;tornado&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;SockJSConnection&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="n"&gt;participants&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;set&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;on_open&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;info&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;broadcast&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;participants&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Someone joined.&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;participants&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;on_message&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;message&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;broadcast&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;participants&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;message&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;on_close&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;participants&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;remove&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;broadcast&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;participants&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Someone left.&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;为了举例，聊天不会有任何的内部协议或认证 - 它只是广播消息发送给所有的参与者。&lt;/p&gt;
&lt;p&gt;没错，就这么就可以了。
如果客户端不支持WebSocket的传输，这不要紧，SockJS会回退去使用长轮询传输 -
开发人员只编写一次代码，sockjs-tornado负责抽象协议的差异。&lt;/p&gt;
&lt;p&gt;逻辑是非常简单的：&lt;/p&gt;
&lt;blockquote&gt;
对于每个传入SockJS连接，sockjs-tornado将创建新的连接类的实例，并调用on_open
在on_open中，处理程序将所广播有人有聊天者加入，并把聊天者的self加入参与者集合。
如果从客户端接收到一些消息，ON_MESSAGE将被调用并且消息将被广播给所有参与者
如果客户端断开连接，on_close将其从参与者集合中删除，并广播给剩下的所有参与者他离开了。&lt;/blockquote&gt;
&lt;p&gt;客户端的完整的例子可以在 &lt;a class="reference external" href="https://github.com/mrjoes/sockjs-tornado/blob/master/examples/chat/chat.py"&gt;这里找到&lt;/a&gt; 。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id21"&gt;
&lt;h2&gt;管理状态&lt;/h2&gt;
&lt;p&gt;服务器端的session是状态的一个例子。如果服务器需要某种先行数据才能处理请求，那服务器是状态相关的。&lt;/p&gt;
&lt;p&gt;状态增加了复杂性 - 它消耗内存，它使伸缩更加困难。
例如，如果没有共享的session状态，客户只能和集群中的一台服务器&amp;quot;说话&amp;quot;。
共享会话状态 - 在为每一个请求从存储中获取状态的时候，每一次数据交换会有额外的IO开销。&lt;/p&gt;
&lt;p&gt;不幸的是，无状态的Comet服务器是不可能实现。为了保持逻辑连接，需要一些会话状态来确保数据在客户端之间数据不会丢失。&lt;/p&gt;
&lt;p&gt;根据任务，可以将有状态的网络层（Comet）和无状态的业务层（实际应用）分离开来。
在这种情况下，业务层完全不需要异步 - 接收到的任务，对其进行处理，并发送回响应。
因为worker是无状态的，就可以并行地启动大量的workers来增加应用程序整体的吞吐量的。&lt;/p&gt;
&lt;p&gt;下面看他是如何工作的，架构图：&lt;/p&gt;
&lt;img alt="" src="images\frontend-worker.png" /&gt;
&lt;p&gt;在这个例子中，使用Redis做同步传输，但是这会有单点故障，从可靠性角度来看不是太好。
此外，Redis的队列被用来向workers推送请求，并接收他们的响应。&lt;/p&gt;
&lt;p&gt;由于网络层是有状态的，运行在应用程序前面负载均衡程序为了满足实时连接将使用粘性sessions（客户端应该每次去到相同的服务器）。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id22"&gt;
&lt;h2&gt;与WSGI应用集成&lt;/h2&gt;
&lt;p&gt;显然，使用新的异步框架重写现有的Web站点是不太可行的。但是可以让他们共存。&lt;/p&gt;
&lt;p&gt;有两种方法来整合实时部分：&lt;/p&gt;
&lt;blockquote&gt;
1， 在同一进程
2， 不在同一进程&lt;/blockquote&gt;
&lt;p&gt;如果使用GEVENT，它是可以使WSGI应用与实时部分共存于相同的进程。
如果使用tornado和其他基于回调的框架，尽管实时部分有可能运行在相同的进程中单独的线程，但是不被推荐这样做，
这有性能方面的问题（由于GIL ）。&lt;/p&gt;
&lt;p&gt;另外，我更喜欢独立进程的方法，其中单独设置进程/服务负责实时部分。
他们可能共存在一个项目/代码库，但他们总是同时但是单独进程运行的。&lt;/p&gt;
&lt;p&gt;让我们假设你有一个社交网络，并希望实时推动状态更新。&lt;/p&gt;
&lt;p&gt;最直接的方式来完成这个事情将是：建立单独的服务器来处理实时连接和监听从主站应用发来通知。&lt;/p&gt;
&lt;p&gt;通知的实现可以通过实时服务提供的定制的REST API（适用于小型部署），
通过Redis的发布/订阅功能（很有可能你的项目已经使用Redis的东西了），
以及在ZeroMQ的帮助下，使用AMQP的消息总线（如RabbitMQ ）等。&lt;/p&gt;
&lt;p&gt;在这篇文章中我们将分析简单的推送broker架构。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id23"&gt;
&lt;h2&gt;组织你的代码&lt;/h2&gt;
&lt;p&gt;我会用Flask作为一个例子，但同样可以应用到任何其他的框架（Django，Pyramid等）。&lt;/p&gt;
&lt;p&gt;我更喜欢一个代码仓库包含Flask应用和基于Tornado的实时部分。
在这种情况下，可以在这两个项目之间复用一些代码。&lt;/p&gt;
&lt;p&gt;对于Flask，我使用普通的Python库：SQLAlchem??y，redis-PY等，对应Tornado，
我必须使用异步的替代库或者使用线程池来执行长时间运行的同步函数，以防止阻塞ioloop。&lt;/p&gt;
&lt;p&gt;我manage.py有两个命令：启动Web应用程序和启动基于tornado的实时部分。&lt;/p&gt;
&lt;p&gt;让我们看看一些用例。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="broker"&gt;
&lt;h2&gt;推送broker&lt;/h2&gt;
&lt;p&gt;Broker接受从Flask应用发来的消息，并将其转发到已连接的客户端。
有很多现成可以使用的broker服务（ PubNub ， Pusher及一些其他的或自托管解决方案，如Hookbox ），
但由于某种原因你可能要搭建自己的。&lt;/p&gt;
&lt;p&gt;这最简单的推送broker：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;BrokerConnection&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sockjs&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;tornado&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;SockJSConnection&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="n"&gt;participants&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;set&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;on_open&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;info&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;participants&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;on_message&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;message&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;pass&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;on_close&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;participants&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;remove&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="nd"&gt;@classmethod&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;pubsub&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cls&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="n"&gt;msg_type&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;msg_chan&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;msg&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;data&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;msg_type&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;message&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;cls&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;clients&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;send&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;msg&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;__name__&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;__main__&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="c"&gt;# .. initialize tornado&lt;/span&gt;
    &lt;span class="c"&gt;# .. connect to redis&lt;/span&gt;
    &lt;span class="c"&gt;# .. subscribe to key&lt;/span&gt;
    &lt;span class="n"&gt;rclient&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;subscribe&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;BrokerConnection&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;pubsub&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;完整的 &lt;a class="reference external" href="https://gist.github.com/mrjoes/3284402"&gt;例子在这里&lt;/a&gt; 。&lt;/p&gt;
&lt;p&gt;broker是无状态的 - 他们真的不存储任何特定于应用程序的状态，
这样你就可根据不断增加的负载启动你需要数量的broker，只要负载正确配置好了。&lt;/p&gt;
&lt;img alt="" src="images\push-servers.png" /&gt;
&lt;/div&gt;
&lt;div class="section" id="id25"&gt;
&lt;h2&gt;游戏&lt;/h2&gt;
&lt;p&gt;让我们为一个&amp;quot;典型&amp;quot;的纸牌游戏做个架构草案。&lt;/p&gt;
&lt;p&gt;假设，有一桌子，一组玩家在玩同一个游戏。
桌子可能包含可见牌和桌面的信息。
每个玩家有其内部状态 - 手上牌的列表，以及一些身份验证数据。&lt;/p&gt;
&lt;p&gt;此外，对于游戏，客户端应该比较智能点，因为有可能需要有基于原始连接的自定义协议的。
为了简单起见，我们将使用定制的基于JSON协议。&lt;/p&gt;
&lt;p&gt;让我们弄清楚我们需要什么样的消息：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;验证&lt;/li&gt;
&lt;li&gt;错误处理&lt;/li&gt;
&lt;li&gt;房间列表&lt;/li&gt;
&lt;li&gt;加入的房间&lt;/li&gt;
&lt;li&gt;摸牌&lt;/li&gt;
&lt;li&gt;出牌&lt;/li&gt;
&lt;li&gt;离开房间&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;认证消息是从客户端发送到服务器的第一条消息。例如，它可以像：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;msg&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;auth&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;token&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;[encrypted-token-in-base64]&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;有效载荷是加密过的令牌，由Flask应用所产生。
有一种方法来生成令牌：获得当前用户ID，用时间戳和一些使用共享密钥加密对称算法（如3DES或AES）随机添加一些东西。
Tornado可以解密令牌，提取出用户ID，然后从数据库进行查询得到任何有关用户的必要的信息。&lt;/p&gt;
&lt;p&gt;房间列表可以类似表示为：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;msg&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;room_list&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;rooms&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;[{&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;name&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;room1&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;},&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;name&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;room2&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;}]}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;依此类推。&lt;/p&gt;
&lt;p&gt;在服务器端，每个SockJS连接被封装在类的实例中，它是可以使用self存储任玩家相关数据。&lt;/p&gt;
&lt;p&gt;Connection类看起来像这个样子（部分）：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;GameConnection&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;SockJSConnection&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;on_open&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;info&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;authenticated&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;False&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;on_message&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="n"&gt;msg&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;json&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;loads&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;msg_type&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;msg&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;msg&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;

        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="ow"&gt;not&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;authenticated&lt;/span&gt; &lt;span class="ow"&gt;and&lt;/span&gt; &lt;span class="n"&gt;msg_type&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;auth&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;send_error&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;authentication required&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="k"&gt;return&lt;/span&gt;

        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;msg_type&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;auth&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;handle_auth&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;msg&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="k"&gt;return&lt;/span&gt;
        &lt;span class="k"&gt;elif&lt;/span&gt; &lt;span class="n"&gt;msg_type&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;join_room&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="c"&gt;# ... other handlers&lt;/span&gt;
            &lt;span class="k"&gt;pass&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;handle_auth&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;msg&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="n"&gt;user_id&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;decrypt_token&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;msg&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;token&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;user_id&lt;/span&gt; &lt;span class="ow"&gt;is&lt;/span&gt; &lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;send_error&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;invalid token&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="k"&gt;return&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;authenticated&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;True&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;send_room_list&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;send_error&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;text&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;send&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;json&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;dumps&lt;/span&gt;&lt;span class="p"&gt;({&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;msg&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;error&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;text&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;text&lt;/span&gt;&lt;span class="p"&gt;}))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;房间可以存储在一个字典里，其中key是房间ID，value是房间对象。&lt;/p&gt;
&lt;p&gt;通过在客户端上实现不同的的消息处理程序和适当的业务逻辑，我们就可以让游戏工作，这作为一个练习留给读者。&lt;/p&gt;
&lt;p&gt;游戏是有状态的 - 服务器必须跟踪在比赛中发生了什么。这也意味着它是有点难以伸缩。&lt;/p&gt;
&lt;p&gt;在上面的例子中，一台服务器处理所有连接的玩家的所有游戏。
但是，如果我们希望有两台服务器并且让玩家分布于它们之间呢？
由于他们不知道对方的状态，连接到第一台服务器的玩家将不能和第二台服务器上的玩家游戏。&lt;/p&gt;
&lt;p&gt;根据游戏规则的复杂性，它是可以使用全连接的拓扑结构 - 每一个服务器连接到每一个其他的服务器：&lt;/p&gt;
&lt;img alt="" src="images\game-interconnect.png" /&gt;
&lt;p&gt;在这种情况下，游戏状态应该需要信息以确定玩家身份，管理他的游戏状态，
并且把游戏相关的信息发送到相应的服务器，这样状态就可以转发给实际客户端。&lt;/p&gt;
&lt;p&gt;虽然这种方法有用，但异步应用程序是单线程的，更好的方式是将游戏逻辑和相关状态分离成单独的服务器应用程序，
把实时部分作为游戏服务器和客户端之间的智能适配器。&lt;/p&gt;
&lt;p&gt;因此，它可以是这样的：&lt;/p&gt;
&lt;img alt="" src="images\realtime-game-servers.png" /&gt;
&lt;p&gt;客户端连接到一个实时服务器，通过验证，获取正在运行的游戏列表（通过游戏服务器和实时服务器之间的一些共享状态）。
当客户端选择特定的游戏玩时，它会发送请求到实时服务器，然后在和真正部署该游戏服务器通信。
虽然这看起来和完全互连解决方案非常相似，但是在同一柜的服务器不需要与对方直接交互，这提供了有效的隔离状态。
伸缩也很简单 - 增加更多的的实时服务器或游戏服务器，由他们的状态是孤立的就易于管理。&lt;/p&gt;
&lt;p&gt;另外，对于这个任务，我会使用ZeroMQ（AMQP总线）而不是Redis的，因为Redis会成为单点故障。&lt;/p&gt;
&lt;p&gt;游戏服务器不会暴露在Internet中，他们只可以通过实时服务器访问。&lt;/p&gt;
&lt;p&gt;我已经说过了，分布式应用程序的伸缩性就看 ** 状态管理是否高效 ** 。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id26"&gt;
&lt;h2&gt;部署&lt;/h2&gt;
&lt;p&gt;把Flask和Tornado放到负载均衡的后面（如haproxy ）
或反向代理服务器（即nginx 是个不错的想法，但要使用最新有WebSocket协议的支持的版本）。&lt;/p&gt;
&lt;p&gt;有三种部署选项：&lt;/p&gt;
&lt;blockquote&gt;
&lt;dl class="docutils"&gt;
&lt;dt&gt;1, 把Web和实时部分都运行在相同的主机和端口，并使用基于URL路由分发&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last"&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;优点&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;所有的事情看起来是一致的&lt;/li&gt;
&lt;li&gt;无需担心跨域脚本问题&lt;/li&gt;
&lt;li&gt;一般可以工作在有防火墙限制的环境&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;缺点&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;一些透明HTTP代理服务器不兼容&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;dt&gt;2, 在相同主机的不同端口，Web在端口80上，实时部分在其他端口&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last"&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;优点&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;和透明代理更加兼容&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;缺点&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;跨域脚本问题（不是每个浏览器都支持CORS ）&lt;/li&gt;
&lt;li&gt;很有可能被防火墙阻止&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;dt&gt;3, Web运行在主要域（site.com）和实时部分运行在子域（subdomain.site.com）&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last"&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;优点&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;可以将实时部分从主站点分离出来（无需使用相同的负载均衡）&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;缺点&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;跨域脚本问题&lt;/li&gt;
&lt;li&gt;会碰到行为古怪的透明代理&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;div class="section" id="id27"&gt;
&lt;h2&gt;现实生活中的经验&lt;/h2&gt;
&lt;p&gt;我看到过一些使用sockjs-tornado的成功案例： &lt;a class="reference external" href="http://blog.playbuildy.com/"&gt;PlayBuildy&lt;/a&gt;  &lt;a class="reference external" href="http://blog.pythonanywhere.com/27/"&gt;PythonAnywhere&lt;/a&gt; 和其他的。&lt;/p&gt;
&lt;p&gt;但不幸的是，我自己没有在大型项目中使用过。&lt;/p&gt;
&lt;p&gt;不过，我有相当有趣的sockjs-node(为nodejs做的SockJS的服务器实现)经验。
我实现了一个比较大的广播电台的实时部分。
在同一时间平均有3500左右连接的客户端。&lt;/p&gt;
&lt;p&gt;大多数连接是短时的，服务器就仅仅是一个简单的broker：
管理有层次的频道订阅（例如广播站事件推送或广播员的新闻推送）和频道日志。
客户订阅频道，应该可以获得所有为子频道推送的更新。
客户也可以申请频道日志 - 按日期排序的最新N个频道和其子频道的消息。
这就是一部分在服务器上的逻辑。&lt;/p&gt;
&lt;p&gt;总体而言，nodejs的表现是很不错的 -
在一台物理服务器上的3个服务器进程就能够毫无压力处理所有这些客户端的链接，
而且还有很多的提升空间。&lt;/p&gt;
&lt;p&gt;但就我看来，nodejs和其库有太多的问题了。&lt;/p&gt;
&lt;p&gt;部署到生产环境后，服务器开始没有明显原因的内存泄漏。
所有的工具表明，堆大小是恒定的，但服务器进程的RSS不断增长，直到进程被操作系统杀掉。
作为一个快速的解决方案，nodejs服务器必须每天晚上重新启动。
这个问题问题和这个这个比较相似，但这个SSL没有关系，因为没有使用SSL。&lt;/p&gt;
&lt;p&gt;如果没有明显的原因的崩溃而且没有产生coredump，那么升级到较新的nodejs版本有帮助。&lt;/p&gt;
&lt;p&gt;如果V8垃圾收集器开始在某些情况下死锁了而且是一天一次的频率发生。
那么升级到较新的nodejs版本会有帮助，它是发生在V8中的死锁，我在Chrominu的bug跟踪服务里面发现了完全相同的堆栈信息。&lt;/p&gt;
&lt;p&gt;新的nodejs版本解决了垃圾收集的问题，应用又可以工作。&lt;/p&gt;
&lt;p&gt;此外，基于回调的编程风格使得代码不是我希望中的那么干净和可读。&lt;/p&gt;
&lt;p&gt;概括起来 - 尽管nodejs能工作，我有一种强烈的感觉是它没有Python那样成熟。
在以后这样的项目中我宁愿使用Python，
因为我可以肯定，如果出现错误，它发生了是因为我出了错，而且问题可以追溯到，这样就相对容易。&lt;/p&gt;
&lt;p&gt;性能方面，使用WebSocket传输，CPython和nodejs 是差不多的而 PYPY比两者都快得多。
对于长轮询，PYPY环境的Tornado在使用适当的异步库的情况下，约1.5-2倍慢于nodejs，因此，
考虑目前的WebSocket兼容状态，我会说他们是可比的。&lt;/p&gt;
&lt;p&gt;我没有理由放弃的Python而用nodejs来做实时部分。&lt;/p&gt;
&lt;p&gt;更新（2013年7月2日）： &lt;a class="reference external" href="http://www.techempower.com/"&gt;TechEmpower&lt;/a&gt; 发布了他们的 &lt;a class="reference external" href="http://www.techempower.com/benchmarks/#section=data-r6&amp;amp;hw=ec2&amp;amp;test=json"&gt;第6轮&lt;/a&gt; 的框架基准测试，新版本的Tornado更快了，或与node.js有的一比。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id29"&gt;
&lt;h2&gt;备注：&lt;/h2&gt;
&lt;p&gt;虽然有人可能会争辩说，要编写出可伸缩的服务器，Python并不是最好的语言。
当然， Erlang的已经有内建的工具来写高效和可扩展的应用程序（而且也有 &lt;a class="reference external" href="https://github.com/sockjs/sockjs-erlang"&gt;sockjs-erlang&lt;/a&gt; ），
但是要找到erlang的开发人员是比较困难的。
Clojure和Scala也是不错的选项，但Java是完全不同的世界，有自己的类库，方法论和约定。
找到不错的Clojure开发者仍然比找到好的Python开发者很难很多。
&lt;a class="reference external" href="http://golang.org/"&gt;Go&lt;/a&gt; 也不错，但他是相当年轻的语言接受程度还不高。&lt;/p&gt;
&lt;p&gt;如果你已经有了Python的经验，你可以继续使用Python达到不错的结果。
在大多数情况下，软件开发就是开发成本和性能之间的一个权衡。
我认为Python所处的位置还比较有利，特别是借助于 &lt;a class="reference external" href="http://www.pypy.org/"&gt;PYPY&lt;/a&gt; 。&lt;/p&gt;
&lt;p&gt;无论如何，如果你有任何意见，问题或更新 - 随时与我联系。&lt;/p&gt;
&lt;p&gt;P.S. 图表是在 &lt;a class="reference external" href="http://draw.io/"&gt;draw.io&lt;/a&gt; 上完成的 -我不得不提一下这个优秀且免费的服务。&lt;/p&gt;
&lt;/div&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">陶克勤</dc:creator><pubDate>Sun, 21 Jul 2013 00:00:00 +0200</pubDate><guid>tag:taokeqin.github.io,2013-07-21:python-realtime.html</guid><category>python</category><category>realtime</category><category>socket.IO</category><category>异步框架</category><category>实时应用</category></item><item><title>写出更好的代码</title><link>http://taokeqin.github.io/write-better-code.html</link><description>&lt;p&gt;最近想看两本书&amp;lt;&amp;lt;数学之美&amp;gt;&amp;gt;和&amp;lt;&amp;lt;暗时间&amp;gt;&amp;gt;
其实这两本书的内容都有零散的看过一些,不过当可以买到纸质书的时候,还是有很想买的欲望.
再次在看暗时间的是否不幸的我点进了这个链接: &lt;a class="reference external" href="http://www.joelonsoftware.com/"&gt;http://www.joelonsoftware.com/&lt;/a&gt;
更不幸的是我点进了下面的一篇文章: &lt;a class="reference external" href="http://www.joelonsoftware.com/articles/fog0000000043.html"&gt;The Joel Test: 12 Steps to Better Code&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;看了一下时间,这篇文章已经是2000年的时候写的了,在那个时候就已经用到了下面的这些技术,我只能说程序员的世界发展真的很慢,因为这些技术现在都还在用.
而且有的开发可能现在都还没有完整的run他的这些步骤.&lt;/p&gt;
&lt;p&gt;我想来回答Joel的这些问题,在现代的一个背景下面,在我的知识范围内来看看我能想到写什么?&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;Do you use source control?&lt;/dt&gt;
&lt;dd&gt;&lt;p class="first last"&gt;这个必须有.如果你相对比较怀旧一点,用SVN吧.
如果你又不想依赖于中心服务器,不想看没有个commit log都要从服务器拉取,用分布式的hg 和 git.
如果想更加的现代,可以看看bitbucket.org 和 github.com. 或许这样的合作方式,是十年前没有想到的.&lt;/p&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;Can you make a build in one step?&lt;/dt&gt;
&lt;dd&gt;&lt;p class="first last"&gt;这个可以有,拿设计模式来讲我愿意把这个叫做facade.你做的越少,犯错的机会就越少.&lt;/p&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;Do you make daily builds?&lt;/dt&gt;
&lt;dd&gt;&lt;p class="first last"&gt;这个应该有.我不知道在十年前用什么工具,但是现在做这个的开源工具还是不错的,比如jenkins,buildbot&lt;/p&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;Do you have a bug database?&lt;/dt&gt;
&lt;dd&gt;&lt;p class="first last"&gt;这个必须有.很多私有的系统.开源的也不错: readmin, trac
这样的工具其实很多,对于一个团队来说,果断选择一个,尽快的熟悉起来.&lt;/p&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;Do you fix bugs before writing new code?&lt;/dt&gt;
&lt;dd&gt;&lt;p class="first last"&gt;这个应该有.就想GTD里面说的,如果一个事情在两分钟之内可以完成,为什么不马上就做呢?
我觉得作为一个开发人员怎么能够忍受最近的代码里面有bug呢?&lt;/p&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;Do you have an up-to-date schedule?&lt;/dt&gt;
&lt;dd&gt;&lt;p class="first last"&gt;这个对于开发来说貌似是家常便饭.开发人员真的很喜欢:&amp;quot;It will be done when it's done!&amp;quot;
不要问我什么时候能完成,我真的不确定?
这篇文章还是不错的: &lt;a class="reference external" href="http://www.joelonsoftware.com/items/2007/10/26.html"&gt;Evidence Based Scheduling&lt;/a&gt;
如果现在让我来评估:经验+风险评估&lt;/p&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;Do you have a spec?&lt;/dt&gt;
&lt;dd&gt;&lt;p class="first last"&gt;这个可以有.看过别人写的spec,感觉需要有比较高度的认识才能完成,这是我需要的技能.&lt;/p&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;Do programmers have quiet working conditions?&lt;/dt&gt;
&lt;dd&gt;&lt;p class="first last"&gt;这个比较困难吧.&lt;/p&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;Do you use the best tools money can buy?&lt;/dt&gt;
&lt;dd&gt;&lt;p class="first last"&gt;best的定义其实不好说,现在很多不要钱的工具用的好同样够威力.&lt;/p&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;Do you have testers?&lt;/dt&gt;
&lt;dd&gt;&lt;p class="first last"&gt;这个问题不是在问我.不过我觉得tester还是必要的,毕竟需要术业有专攻.&lt;/p&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;Do new candidates write code during their interview?&lt;/dt&gt;
&lt;dd&gt;&lt;p class="first last"&gt;必须.&lt;/p&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;Do you do hallway usability testing?&lt;/dt&gt;
&lt;dd&gt;&lt;p class="first last"&gt;这个貌似是为GUI程序或者网页程序来的问题啊?&lt;/p&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通过读者个感觉我必须要从理论上去解决两个问题:&lt;/p&gt;
&lt;p&gt;1, &lt;strong&gt;怎么更好的进行schecule&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;2, &lt;strong&gt;如何写spec.&lt;/strong&gt;&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">陶克勤</dc:creator><pubDate>Tue, 05 Jun 2012 00:00:00 +0200</pubDate><guid>tag:taokeqin.github.io,2012-06-05:write-better-code.html</guid><category>maths</category><category>book</category></item><item><title>最近对编程的一些感想</title><link>http://taokeqin.github.io/test-pattern-cpp0x.html</link><description>&lt;div class="section" id="id2"&gt;
&lt;h2&gt;1, 测试很重要.&lt;/h2&gt;
&lt;p&gt;接手一堆没有测试的代码,感觉有点害怕.
现在每当拿到一个代码,喜欢干的事情就是先跑他的单元测试.
单元测试全部通过,说明什么呢?
我认为至少说明基本想要完成的功能是没有问题的.&lt;/p&gt;
&lt;p&gt;有了测试代码,其实都可以不需要有太详细的文档了,
合适的命名,加上恰当范围的测试覆盖如果你想对代码有个基本认识应该很简单
而且你对你仅有的认识会比较有信心,写代码的人自己都在怎么用这样一些接口,自己也可以沿袭这个风格进行.&lt;/p&gt;
&lt;p&gt;同样的,如果你要把一部分代码给别人,怎么告诉他你代码当前的状态呢?&lt;/p&gt;
&lt;p&gt;如果你的代码有测试,那么你将会很自信.&lt;/p&gt;
&lt;p&gt;现在我的回答会是:
我的测试覆盖90%,如果文档不能满足你的需求,麻烦你看我的测试,如果你发现了测试没有测的好功能,恭喜你这是个suprise!&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id3"&gt;
&lt;h2&gt;2, 设计模式无处不再.&lt;/h2&gt;
&lt;p&gt;手上有本设计模式的书,一遍一遍的看,每个模式每次看都有不同的认识.
其实代码中真的已经用了很多和模式对等的东西,只是有了这么一个理论摆在这里感觉真的很方便和别人交流.
对于再次利用总结出来的牛逼设计模式,也比较能给自己信心.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="c-0x"&gt;
&lt;h2&gt;3, 期待c++0x早日进入产品代码&lt;/h2&gt;
&lt;p&gt;当前产品代码中还是有大量的用到boost::function, bind, shared_ptr等,毕竟不太需要编译器对新语言的特别支持.
期待完全支持c++0x的编译器出来,期待以后产品代码中都用这些东西.现在让自己开始熟悉这些.&lt;/p&gt;
&lt;p&gt;今天和朋友讨论了一个问题, 感觉很有意思: &lt;strong&gt;什么样的特性应该或者可以被加入新的标准中?&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我的一个认识就是:&lt;/p&gt;
&lt;p&gt;一旦一个语言已经标准化,就意味着这个语言的核心集合已经确定,并且在以后的发展会考虑强烈的需求向后兼容.
所以新的标准不会加入太多的东西,而且加入的都是一些对广大开发者共同的需求,这些新加的特性要么改进语言的用法,要么适应当前业界的一个强烈需求.
而且不回break以前的代码.
比如auto, lambda, concurency.
核心语言要足够的简单(当然c++当前已经很不简单),一些更高级的用法用库来实现.比如STL, boost&lt;/p&gt;
&lt;/div&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">陶克勤</dc:creator><pubDate>Mon, 04 Jun 2012 00:00:00 +0200</pubDate><guid>tag:taokeqin.github.io,2012-06-04:test-pattern-cpp0x.html</guid><category>design pattern</category><category>test</category></item><item><title>c++0x_lambda</title><link>http://taokeqin.github.io/lambda-in-c++0x.html</link><description>&lt;p&gt;看了一下,这些关于lambda的讨论,貌似都是在09年左右,不过我感觉还是很有价值的.&lt;/p&gt;
&lt;p&gt;权威文档的话参考SPEC &lt;a class="footnote-reference" href="#id5" id="id1"&gt;[1]&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;从SPEC来看,lambda的语法上还是很多细节需要注意的,但是要想掌握其用法应该稍加练习就可以了.&lt;/p&gt;
&lt;p&gt;第二个网页 &lt;a class="footnote-reference" href="#id6" id="id2"&gt;[2]&lt;/a&gt; 讲一些vc10对lambda的支持,从这篇文章基本上可以看到lambda在使用上的全貌.&lt;/p&gt;
&lt;p&gt;第三个页面 &lt;a class="footnote-reference" href="#id7" id="id3"&gt;[3]&lt;/a&gt; 我比较喜欢,stackoverflow你懂的.&lt;/p&gt;
&lt;p&gt;其实boost中已经有lambda的实现了,之前有练习过用法,没有太深入.
如果我没有记错的话boost::lambda使用上更加简洁,但限制比较多,但是功能没有std::lambda强大.
需要看看各个编译器对std::lambda的支持程度了,如果这个程度到了一个比较好的阶段,估计很多人都只会用std的了.&lt;/p&gt;
&lt;p&gt;看看网页 &lt;a class="footnote-reference" href="#id8" id="id4"&gt;[4]&lt;/a&gt; ,当我们有了auto, lambda再加上我们牛X的stl,代码写起来有木有感觉想在写脚本?
worth to try!&lt;/p&gt;
&lt;table class="docutils footnote" frame="void" id="id5" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id1"&gt;[1]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;SPEC: &lt;a class="reference external" href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2009/n2927.pdf"&gt;http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2009/n2927.pdf&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="id6" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id2"&gt;[2]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;easy sample: &lt;a class="reference external" href="http://blogs.msdn.com/b/vcblog/archive/2008/10/28/lambdas-auto-and-static-assert-c-0x-features-in-vc10-part-1.aspx"&gt;http://blogs.msdn.com/b/vcblog/archive/2008/10/28/lambdas-auto-and-static-assert-c-0x-features-in-vc10-part-1.aspx&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="id7" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id3"&gt;[3]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;discuss: &lt;a class="reference external" href="http://stackoverflow.com/questions/1203808/c0x-lambdas-coding-style"&gt;http://stackoverflow.com/questions/1203808/c0x-lambdas-coding-style&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table class="docutils footnote" frame="void" id="id8" rules="none"&gt;
&lt;colgroup&gt;&lt;col class="label" /&gt;&lt;col /&gt;&lt;/colgroup&gt;
&lt;tbody valign="top"&gt;
&lt;tr&gt;&lt;td class="label"&gt;&lt;a class="fn-backref" href="#id4"&gt;[4]&lt;/a&gt;&lt;/td&gt;&lt;td&gt;practice lambda: &lt;a class="reference external" href="http://www.gamedev.net/blog/32/entry-2254311-the-new-c-lambdas/"&gt;http://www.gamedev.net/blog/32/entry-2254311-the-new-c-lambdas/&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">陶克勤</dc:creator><pubDate>Wed, 30 May 2012 00:00:00 +0200</pubDate><guid>tag:taokeqin.github.io,2012-05-30:lambda-in-c++0x.html</guid><category>lambda</category><category>c++0x</category></item><item><title>接触Clang</title><link>http://taokeqin.github.io/about-clang.html</link><description>&lt;p&gt;以前有接触过Clang,感觉很棒,今天看了这个视频:&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="http://channel9.msdn.com/Events/GoingNative/GoingNative-2012/Clang-Defending-C-from-Murphy-s-Million-Monkeys"&gt;http://channel9.msdn.com/Events/GoingNative/GoingNative-2012/Clang-Defending-C-from-Murphy-s-Million-Monkeys&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;对Clang更加有兴趣了.
演讲者讲得不错,很有激情,很有感染力.&lt;/p&gt;
&lt;p&gt;两个方向我觉得可以研究一下:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;代码重构&lt;/li&gt;
&lt;li&gt;静态分析&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其实对GCC的了解本来也不是很深入,常用的就是优化于警告级别选项而已.希望以后花点时间认真看看Clang.&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">陶克勤</dc:creator><pubDate>Sun, 27 May 2012 00:00:00 +0200</pubDate><guid>tag:taokeqin.github.io,2012-05-27:about-clang.html</guid><category>clang</category></item><item><title>googletest和xUnit架构</title><link>http://taokeqin.github.io/xunit-and-googletest.html</link><description>&lt;p&gt;对于C++的测试，现在我知道两个cppunit和googletest。虽然他们都是写写xUnit构的，但是我偏向于喜欢googletest，可能是自己用得比较熟悉的原因。&lt;/p&gt;
&lt;div class="section" id="xunix"&gt;
&lt;h2&gt;什么是xUnix架构&lt;/h2&gt;
&lt;p&gt;我的一些简单理解，最先那个谁写了一个测试框架，然后大家都用，并且大家后来都觉得这种方式还不错，就这样成了惯例，然后在其他语言也有人根据这种模式写出类似的测试框架，不断的发展就成了xUnit框架，狭义的来讲x泛指各种语言。&lt;/p&gt;
&lt;p&gt;xUnit有一些简单的概念：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;Testcase 测试用例&lt;/dt&gt;
&lt;dd&gt;&lt;p class="first last"&gt;单元测试的基本单元，用来描述一个测试点
完整的测试由很多的测试用例构成&lt;/p&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;Testfixture 测试固件（测试上下文）&lt;/dt&gt;
&lt;dd&gt;&lt;p class="first last"&gt;我觉得翻译为 &lt;strong&gt;测试上下文&lt;/strong&gt; 比较好理解,根据这个翻译就可以看出，测试上下         文就是为了给测试用例提供一个上下文。&lt;/p&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;Testsuit 测试套件&lt;/dt&gt;
&lt;dd&gt;&lt;p class="first last"&gt;把很多测试用例放到一起，共享相同的测试上下文，这就是一测试套件&lt;/p&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;Test execution 测试执行&lt;/dt&gt;
&lt;dd&gt;&lt;p class="first last"&gt;规定了测试用例的执行策略，比如为每个测试用例先建立测试上下文，然后运行测    试用例，对上下文进行清理&lt;/p&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;Test Assertions 测试断言&lt;/dt&gt;
&lt;dd&gt;&lt;p class="first last"&gt;断言这个比较容易理解，即使不再测试架构里面也有用。&lt;/p&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;满足上面的所以概念，他就xUnit了，so easy！&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id1"&gt;
&lt;h2&gt;googletest对应于xUnit&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;测试用例 与 断言&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;TEST&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;test_case_name&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;testname&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;ASSERT_EQ&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个代码是一个 &lt;strong&gt;测试用例&lt;/strong&gt; 的例子，在googletest中，在同一个测试用例下可以有
很多不同名字的测试,testname需要不一样。 &lt;strong&gt;断言&lt;/strong&gt; 也出现在了上面的代码中，googletest中还有各种断言。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;测试固件 与 测试套件&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;MyTest&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="k"&gt;public&lt;/span&gt; &lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;testing&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Test&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="nl"&gt;protected:&lt;/span&gt;
                &lt;span class="n"&gt;MyTest&lt;/span&gt;&lt;span class="p"&gt;(){}&lt;/span&gt;
                &lt;span class="k"&gt;virtual&lt;/span&gt; &lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="n"&gt;MyTest&lt;/span&gt;&lt;span class="p"&gt;(){}&lt;/span&gt;

                &lt;span class="k"&gt;virtual&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;SetUp&lt;/span&gt;&lt;span class="p"&gt;(){}&lt;/span&gt;
                &lt;span class="k"&gt;virtual&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;TearDown&lt;/span&gt;&lt;span class="p"&gt;(){}&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="n"&gt;TEST_F&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;MyTest&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;TEST_NAME_1&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;ASSERT_EQ&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="n"&gt;TEST_F&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;MyTest&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;TEST_NAME_2&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;ASSERT_EQ&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在googletest里面，需要固件就让你的testcase从::testing::Test派生出来。那测试
固件在那里呢？就在于通过这种方式，可以为你的测试用例提供一个上下文，你可以在
构造函数，SetUp函数中准备你的上下文，然后在析构函数和TearDown函数中进行必要
的清理。那测试套件又在那里呢？我的理解是逻辑上的来讲，整个就是一测试套件。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;测试执行&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;那测试套件的执行来说，就是创建测试上下文，执行测试用例下面的一个测试，清理上下文。然后从新再来&lt;/p&gt;
&lt;/div&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">陶克勤</dc:creator><pubDate>Fri, 06 Apr 2012 00:00:00 +0200</pubDate><guid>tag:taokeqin.github.io,2012-04-06:xunit-and-googletest.html</guid><category>xunit</category><category>googletest</category></item><item><title>googlemock中遇到pthread问题</title><link>http://taokeqin.github.io/a-compile-problem-of-googlemock.html</link><description>&lt;p&gt;今天在搭建googlemock的环境，以前都没有出过问题，今天居然碰到了，
直接checkout googlemock的代码，然后到make文件夹下面直接make，居然连接的时候连接不上，报pthread中的东西找不到。
各种check：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;连接参数是否有 -lpthread&lt;/dt&gt;
&lt;dd&gt;&lt;p class="first last"&gt;有&lt;/p&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;locate pthread&lt;/dt&gt;
&lt;dd&gt;&lt;p class="first last"&gt;系统中也有&lt;/p&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;g++ -print-search-dirs&lt;/dt&gt;
&lt;dd&gt;&lt;p class="first last"&gt;前面找到的库也在路径中&lt;/p&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;直接把找到的pthread路径用-L写在makefile中&lt;/dt&gt;
&lt;dd&gt;&lt;p class="first last"&gt;还是报错&lt;/p&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;经过上面的步骤我觉得应该是能够解决我的问题的，什么状况，感觉超出了我的能力。。。&lt;/p&gt;
&lt;p&gt;经过各种google，都没有找出问题来。&lt;/p&gt;
&lt;p&gt;没办法了，各种尝试，记得最后成功的方式：把-lpthread放到了连接参数的后面，看下面的diff&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;--- Makefile    (revision 404)
+++ Makefile    (working copy)
@@ -95,4 +95,4 @@
$(CXX) $(CPPFLAGS) $(CXXFLAGS) -c $(USER_DIR)/gmock_test.cc

gmock_test : gmock_test.o gmock_main.a
-       $(CXX) $(CPPFLAGS) $(CXXFLAGS) -lpthread $^ -o $@
+       $(CXX) $(CPPFLAGS) $(CXXFLAGS) $^ -o $@ -lpthread
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;初步原因，这个取决于连接器在链接是加载文件的顺序有关系：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;g++ -o gmock_test gmock_test.o gmock_main.a -lpthread
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面是我可以成功编译的命令，可以看出加载的顺序是从右到左的。&lt;/p&gt;
&lt;p&gt;从这个文档可以看到下面的解释：&amp;lt;&lt;a class="reference external" href="http://gcc.gnu.org/onlinedocs/gcc-4.7.0/gcc/Link-Options.html#Link-Options"&gt;http://gcc.gnu.org/onlinedocs/gcc-4.7.0/gcc/Link-Options.html#Link-Options&lt;/a&gt;&amp;gt;&lt;/p&gt;
&lt;div class="note"&gt;
&lt;p class="first admonition-title"&gt;Note&lt;/p&gt;
&lt;p class="last"&gt;It makes a difference where in the command you write this option;
the linker searches and processes libraries and object files in the order they are specified.
Thus, 'foo.o -lz bar.o' searches library 'z' after file foo.o but before bar.o.
If bar.o refers to functions in 'z', those functions may not be loaded.&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;不过看起来这个说明和我遇到的实际情况刚好相反，没有继续求证，但应该就是这个问题。
所以以后编译链接有问题 &lt;strong&gt;链接器的加载顺序&lt;/strong&gt; 需要考虑&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">陶克勤</dc:creator><pubDate>Mon, 02 Apr 2012 00:00:00 +0200</pubDate><guid>tag:taokeqin.github.io,2012-04-02:a-compile-problem-of-googlemock.html</guid><category>googlemock</category><category>g++</category></item></channel></rss>